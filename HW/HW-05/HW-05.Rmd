---
title: "HW-05"
author: "Sterling Hayden"
date: "2024-10-17"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(fpp3)
library(fable)
library(fabletools)
library(lubridate)
library(expsmooth)
library(lmtest)
library(zoo)
library(seasonal)
library(ggplot2)
library(seasonalview)
library(aTSA)
library(tsibble)
library(fable)
library(tidyverse)
library(imputeTS)
library(fable.prophet)

```


# Load data
```{r}
#read in the csv
train <- read.csv('../HW-04/hrl_load_metered.csv')
test1 <- read.csv('../HW-04/hrl_load_metered-test1.csv')
test2 <- read.csv('../HW-04/hrl_load_metered-test2.csv')
test3 <- read.csv('hrl_load_metered-test3.csv')
test4 <- read.csv('hrl_load_metered-test4.csv')

#format
train$datetime_beginning_ept <- as.POSIXct(train$datetime_beginning_ept,
                                              format = "%m/%d/%y %H:%M",
                                              tz = "America/New_York")
test1$datetime_beginning_ept <- as.POSIXct(test1$datetime_beginning_ept,
                                              format = "%m/%d/%y %H:%M",
                                              tz = "America/New_York")
test2$datetime_beginning_ept <- as.POSIXct(test2$datetime_beginning_ept,
                                              format = "%m/%d/%y %H:%M",
                                              tz = "America/New_York")
test3$datetime_beginning_ept <- as.POSIXct(test3$datetime_beginning_ept,
                                              format = "%m/%d/%y %H:%M",
                                              tz = "America/New_York")
test4$datetime_beginning_ept <- as.POSIXct(test4$datetime_beginning_ept,
                                              format = "%m/%d/%y %H:%M",
                                              tz = "America/New_York")

#newest test keep as test
test <- test4
#join the train and test1
train <- rbind(train,test1,test2,test3)

nrow(train)
nrow(test)

tail(train)
head(test)
```


# Data Preprocessing and Creating a Tsible object
```{r}
#remove duplicates by grouping then calculating the average then ungrouping
train <- train %>%
  group_by(datetime_beginning_ept) %>%
  summarise(
    mw = mean(mw, na.rm = TRUE), #calculate the mean mw for each datetime_beginning_ept
    .groups = 'drop' #ungroup the data
  )
test <- test %>%
  group_by(datetime_beginning_ept) %>%
  summarise(
    mw = mean(mw, na.rm = TRUE),
    .groups = 'drop'
  )

#convert to tsible
train.ts <- train %>% 
  select(datetime_beginning_ept, mw) %>% 
  as_tsibble(index = datetime_beginning_ept)
test.ts <- test %>% 
  select(datetime_beginning_ept, mw) %>% 
  as_tsibble(index = datetime_beginning_ept)

#account for missing data
#fill the missing time gaps with NA's
train.ts <- tsibble::fill_gaps(train.ts)
test.ts <- tsibble::fill_gaps(test.ts)
#impute the NA's with the average between the t-1 and t+1
train.ts <- train.ts %>%
  na_interpolation(option = "spline")
test.ts <- test.ts %>%
  na_interpolation(option = "spline")
```


# Prophet Model
- Forecast this model for your validation set only. 
- Calculate the MAE and MAPE for the validation set. 
```{r}
#A higher order allows the seasonal component to capture more complex and non-linear seasonal patterns in the data.
fit_prophet <- train.ts |>
  model(
    prophet(mw ~
            season(period = "day", order = 7) +
            season(period = "week", order = 3) +
            season(period = "year", order = 5))
  )

fit_prophet |>
  components() |>
  autoplot()
```


```{r}
fc_prophet <- fit_prophet |>
  fabletools::forecast(new_data = test.ts)

autoplot(fc_prophet, level = NULL) +
  autolayer(test.ts, mw, color = "black") +
  labs(y="MW Usage", x="Date (Hourly Format)", title="Prophet Model")
```

```{r}
fabletools::accuracy(fc_prophet, test.ts)
```

```{r}
library(scales)
graphDF <- data.frame(
  forecast = fc_prophet,
  actual = test.ts$mw,
  time = test.ts$datetime_beginning_ept
)

P_MAPE_hand=5.70
plot <- ggplot(data = graphDF, aes(x = time)) + 
geom_line(aes(y = forecast..mean, color = "Prophet \nForecast"), linewidth = 1.2, alpha =.7) + 
geom_line(aes(y = actual,color = "Observed"),linetype = "twodash",linewidth = 1.5) + 
scale_color_manual(values = c("Observed" = "black", "Prophet \nForecast" = "orange")) + 
scale_y_continuous(labels = comma) + 
labs(colour = "",
     title = paste0("Forecasted MW Usage for ","Prophet Model",""),
     subtitle = paste0("09/13/2024- 09/19/2024\n","MAPE: ",P_MAPE_hand,"\n"),
     y ="Hourly\nMW",
     x = "") + 
theme_classic() + 
theme(axis.title.y = element_text(angle = 0,vjust = .5))

print(plot)
```

```{r}
head(graphDF)
```


# Neural Network Model
- Describe the approach you used to select the lags of the model.  
- Forecast this model for your validation set only. 
- Calculate the MAE and MAPE for the validation set. 


Should we difference?
```{r}
gg_tsdisplay(train.ts[1:15000,])
```
Seems like we should difference

```{r}
train.ts %>% 
  features(mw, unitroot_nsdiffs)

train.ts %>% 
  features(difference(mw, 24), unitroot_nsdiffs)
```
1 seasonal difference does the trick.

```{r}
ggPacf(difference(train.ts$mw, 24),lag.max = 100)
```
p=2, P=3or4
The PACF shows a significant spike at Lag 2, which indicates that the first lag is a strong predictor of the current observation.
There is also a significant spike at Lag 48 and 72 and (3rd and 4th seasonal lag), suggesting that the value from 24 periods (hours) ago also significantly influences the current observation.


```{r}
train.ts_diff <- train.ts %>%
  mutate(diff_mw = difference(mw, 24))

set.seed(8)
model_nnet <- train.ts_diff %>%
  model(hand1 = NNETAR(diff_mw ~ AR(p = 2, P = 4), n_nodes = 5))

# check output of models
model_nnet %>%
  select(hand1) %>%
  report()
```
```{r}
#load("model.RData")
model_nnet_for <- forecast::forecast(model_nnet, test.ts)
save(model_nnet_for, file = "model.RData")

```

```{r}
#THIS FOR DAY
nnet_for_hand1 <- rep(NA, 24) # empty vector

# add the forecasted differences to the previous season's value (hand model)
# for hourly: 24: needed to add difference based on previous predicted values
for(i in 1:24){
  nnet_for_hand1[i] <- train.ts$mw[length(train.ts$mw) - 24  + i] + model_nnet_for$.mean[i]
}

# manually calculate values 
NN_error_hand1 <- test.ts$mw - nnet_for_hand1
NN_MAE_hand1 <- mean(abs(NN_error_hand1))
NN_MAPE_hand1 <- mean(abs(NN_error_hand1)/abs(test.ts$mw))*100
NN_MAE_hand1
NN_MAPE_hand1

```

```{r}
#THIS FOR WEEK
nnet_for_hand <- rep(NA, 168)

for(i in 1:168){
  nnet_for_hand[i] <- train$mw[length(train$mw) - 168 + i] + 
    model_nnet_for$.mean[i]}

NN_error_hand <- test$mw - nnet_for_hand
NN_MAE_hand <- mean(abs(NN_error_hand))
NN_MAPE_hand <- mean(abs(NN_error_hand)/abs(test$mw))*100
```



```{r}
NN_MAPE_handuse = 3.39
plot <- ggplot(data = test.ts, aes(x = datetime_beginning_ept)) + 
geom_line(aes(y = nnet_for_hand, color = "Neural Network \nForecast"), linewidth = 1.2,alpha =.7) +
geom_line(aes(y = mw,color = "Observed"),linetype = "twodash",linewidth = 1.5) + 
scale_color_manual(values = c("Observed" = "black", "Neural Network \nForecast" = "orange")) + 
labs(colour = "",
     title = paste0("Forecasted MW Usage for ","Neural Network Model",""),
     subtitle = paste0("09/13/2024- 09/19/2024\n","MAPE: ",NN_MAPE_handuse,"\n"),
     y ="Hourly\nMW",
     x = "") + 
theme_classic() + 
theme(axis.title.y = element_text(angle = 0,vjust = .5))

print(plot)
```